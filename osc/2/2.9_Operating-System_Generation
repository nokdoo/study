하나의 site, 하나의 machine에 대해 os를 설계, 코딩, 구현하는 것은 가능하다. 그러나 대부분의 경우 os는 지엽적이고 다양한 환경에서 다양한 종류의 machine에서 실행되도록 설계 된다. 그런다음 시스템은 특정 system generation SYSGEN이라는 site에 맞게 구성되거나 생성되어야 한다.

보통 os는 디스크, 시디롬, 디비디롬. ISO파일로 분산되어 있다. 시스템을 생성하기 위해서는 SYSGEN이라는 특별한 프로그램을 사용해야 한다. 이 프로그램은 주어진 파일을 읽거나, 시스템 관리자에게 하드웨어의 configuration 정보를 요청하거나, 어떤 component가 하드웨어에 존재하는지 직접 probe한다. 다음의 정보는 결정되어야 한다.
	- 어떤 cpu가 사용되는가? 어떤 요소가 설치될 것인가? multiple cpu system에서 각 cpu는 설명가능 해야한다.
	- 부팅 디스크가 어떻게 포맷될 것인가? 얼마나 많은 파티션으로 분할될 것이고 각 파티션에는 무엇이 들어갈 것인가?
	- 메모리를 얼마나 이용 가능한가? 어떤 시스템은 메모리의 참조 주소부터 "illegal address"가 나올때 까지를 메모리의 값으로 결정한다. 이 방법은 final legal address를 이용가능한 메모리의 총합으로 정의한다.
	- 어떤 장치를 이용 가능한가? 시스템은 장치를 다루는 방법, 장치의 인터럽트 숫자, 장치의 타입과 모델, 장치의 특성을 알아야 한다.
	- 어떤 os의 옵션이 필요한가, 어떤 파마리터 값이 사용되는가? 이 값들에는 버퍼가 얼마나 사용되어야 하는지, 어떤 타입의 cpu스케쥴링 알고리즘이 필요한지, 최대 몇 개의 프로세서가 지원될 수 있는지 등의 정보가 들어있다.

정보는 한번 결정되면 다양한 방법으로 사용될 수 있다. 극단적인 예로 한 시스템 관리자는 os의 소스코드 복사본을 수정하기 위해서 이를 사용할 수 있다. 이때 os는 온전하기 컴파일 된다. data 선언, 초기화, 상수는 조건적인 컴파일과 함께 구성된 시스템에 알맞은 os의 출력물을 생성한다.

조금 부족한 level에서 system description은 미리 컴파일된 라이브러리에서 모듈을 선택하고 테이블을 생성할 수 있다. 이 모듈은 생성된 os를 구성하기 위해서 서로 link된다. 모듈의 선택은 라이브러리가 os에 link된 io장치를 위한 드라이버를 포함하도록 한다. system이 재컴파일 되지 않기 때문에 system의 생성은 속도가 빠르지만 지나치게 일반적인 결과의 system이 된다.

반대의 극단적인 예로, 완전한 테이블일 구성된 시스템을 만드는 것이 가능하다. 모든 코드는 시스템이 일부분이며 선택은 컴파일 시간이나 link time보다는 실행시간에 일어난다. system generation은 시스템을 구성하기 위한 적절한 테이블을 간단하게 생성한다.

이 방법들의 다른 점은 생성된 시스템의 크기와 일반성, 그리고 하드웨어의 변경에 따른 수정의 용이성이다. 새로운 요구에 따른 시스템의 수정비용을 고려해라. 
