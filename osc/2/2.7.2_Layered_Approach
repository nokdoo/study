적절한 하드웨어의 사용으로 os는 더 작고 적합하게 분리될 수 있다.
하나의 방법은 os를 0-N의 layer로 분리시키는 layered approach이다.
최하위 계층(0)은 하드웨어를 가리키며, 최상위 계층(N)은 유저 인터페이스를 가리킨다.
각 layer는 데이터와 데이터를 조작하는 연산자로 구성되어 있는 추상객체이다.

layered os의 장점은 생성과 디버깅이 쉽다는 것이다.
layer는 자신보다 하위 layer의 서비스와 함수를 사용하기 위해 선택된다.
하나의 layer가 디버깅 되면 그 layer는 확실하다고 추정할 수 있다. 
하나의 layer에 대해 디버깅이 끝나면 다음 layer의 디버깅이 이루어진다.

첫번째 layer는 목표가 되는 하드웨어만을 사용하기 때문에 
다른 시스템의 상태를 신경쓰지 않고 디버깅될 수 있다.

각 layer는 하위 layer로부터 제공받은 연산자로 구현된다.
각 layer는 다른 layer의 연산자가 어떻게 구현되었는지 알 필요가 없기 때문에, 
	각 layer는 자료구조, 연산자 등을 숨긴다.

layered approach는 하나의 layer는 오직 하나의 하위 layer를 사용할 수 있기 때문에 신중한 계획이 요구된다.
예를 들어 보조기억장치 드라이버는 메모리 관리 루틴보다 낮은 layer에 있어야 한다.
메모리 관리는 보조메모리를 사용할 능력이 요구되기 때문이다.

명백하지 않은 요구사항들도 존재한다.
일반적으로 보조기억장치 드라이버는 cpu scheduler가 reschedule하는 과정을 기다리기 때문에
cpu scheduler보다 위에 위치하지만, 
cpu scheduler는 메모리에  수용할 수 있는 것보다 많은 프로세스의 정보를 가지고 있기 때문에
메모리의 swap이 필요하고, 보조기억장치 드라이버가 cpu scheduler보다 낮은 곳에 위치해야한다.

---뭔소리야... 상위 layer가 작업을 수행하기 위해서 하위 layer의 이용이 필요하다? 인가... ---

무엇보다 layered implementation의 문제는 다른 형식보다 비효율적이다는 것이다.
각 layer를 넘나들면서 parameter가 바뀌고 자료가 넘겨지면서 오버헤드가 발생한다.
이는 시간 지연으로 이어지게 된다.

요즘에는 layer간의 상호작용의 문제를 피하면서 모듈화의 장점을 제공하는, 
더 많은 기능을 갖춘 layer가 설계되고 있다.
