os가 생성되면 하드웨어에 의해 사용 가능하도록 만들어져야 한다. 하지만 하드웨어가 커널이 어디에 있는 어떻게알 것이며, 커널에 load할 수 있겠는가? 컴퓨터가 시작될 때 커널을 로딩하는 과정은 booting 이라고 알려져 있다. 대부분의 컴퓨터는 bootstrap program또는 bootstrap loader라고 알려진 코스의 작은 조각이 커널에 위치하고, 이들을 메인 메모리에 load하고 이것을 실행시킨다. pc와 같은 몇몇 컴퓨터는 두 단계의 프로세서를 사용한다. 이 프로세스는 간단한 bootstrap loader가 복잡한 boot program을 디스크에서 가져오고 커널을 순차적으로 load한다.

cpu가 리셋 이벤트를 받게 되면(전원을 키거나 재부팅하거나), 명령 레지스터는 미리 정의된 메모리위치에 load되고 실행된다. 이 위치에 초기 bootstrap program이 있다. 이 프로그램은 read-only memory(ROM)의 형태로 존재한다. RAM은 시스템 시작시 알려지지 않은 상태이기 때문이다. 롬은 초기화가 필요 없고 컴퓨터 바이러스에 쉽게 영향을 받지 않기 때문에 간편하다. bootstrap program은 다양한 task를 수행한다. 보통 하나의 task는 machine의 상태를 결정하기 위해서 diagnostic을 실행시킨다. diagnostic이 통과하면 프로그램은 부팅단계를 이어나갈 수 있다. 이것은 또한 cpu레지스터에서 장치 관리자, 메인 메모리의 내용과 같은 시스템의 모든 요소를 초기화 할 수 있다.

휴대폰, 태블릿, 콘솔게임과 같은 시스템은 롬에 os의 모든 것을 저장한다. os를 롬에 저장하는 것은 하드웨어와 견고한 operation을 간단히 지원하는데 적합하다. 이 방법의 문제는 bootsrap code의 변경이 롬 하드웨어 칩의 변경을 요구한다는 것이다. 몇몇 시스템은 이 문제를 erasable programmable read-only memory(EPROM)을 이용해 해결하였다. EPROM은 명시적으로 쓰기 가능한 명령어가 주어질 때를 제외하면 읽기만 가능하다. 롬은 하드웨어와 소프트웨어의 사이의 특성을 가지고 있기 때문에 firmware로 알려져 있다. 일반적으로 펌웨어에 대한 문제는 코드를 실행하는데 있어서 RAM보다 느리다는 것이다. 몇몇 시스템은 펌웨어에 os를 저장하고 이를 ram에 저장함으로써 이 문제를 보완한다. 펌웨와의 마지막 이슈는 가격이 상대적으로 비싸기 때문에 작은 시스템에서만 이용이 가능하다는 것이다.

널리 이용되는 큰 os이나 자주 변경되는 system를 보면 bootstrap loader는 펌웨어 안에 저장되어 있고. os는 디스크에 저장되어 있다. bootstrap은 diagnostic을 실행시키고 고정된 위치의 단일 블록을 읽을 수 있으며 boot block으로부터 코드를 실행시킬 수 있다. boot block에 저장된 프로그램은 전체 os를 메모리에 load하고 실행할 정도로 정교할 수 있다. 더욱 간단하게, 프로그램은 간단한 코드이며 디스크 내부의 주소를 알 수 있고 bootstrap grogram의 남은 길이를 알 수 있다. GRUB은 리눅스를 위한 오픈소스 bootstrap grogram의 한 예이다. 모든 disk-bound bootstrap과 os는 디스크를 새롭게 작성하여 쉽게 변경될 수 있다. 하나의 boot partiion을 가지고 있는 디스크를 boot disk또는 system disk라 부른다.

bootstrap program이 모두 load되면 os 커널을 찾기 위해서 파일시스템을 탐색한다. 그리고 커널을 메모리애 로드하고 실행시킬 수 있다. 이 시점을 시스템이 실행중이다라고 말한다.
