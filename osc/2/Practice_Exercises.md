# Practice Exercises
---

#### 2.1 system call의 목적은 무엇인가?

* user-level의 프로세스에게 os의 서비스를 요청할 수 있게 할 수 있도록 한다.

#### 2.2 프로세스 관리와 관련해서 os의 다섯 가지 주요 활동은 무엇인가?
* 사용자 프로세스와 시스템 프로세스를 생성하고 제거.
* 프로세스의 정지와 재개.
* 프로세스 동기화를 위한 메커니즘 제공.
* 프로세스 통신을 위한 메커니즘 제공.
* deadlock handling을 위한 메커니즘 제공.

#### 2.3 메모리 관리와 관련해서 os의 세 가지 주요 활동은 무엇인가?
* 현재 어떤 메모리가 사용되고 있는지, 누가 사용하고 있는지를 추척.
* 메모리 공간이 사용 가능하게 될 때 프로세스가 메모리에 load 되는 것을 결정.
* 필요에 따른 메모리 할당과 반환.

#### 2.4 secondary-storage 관리와 관련해서 os의 세 가지 주요 활동은 무엇인가?
* 비어있는 공간 관리.
* 저장공간 할당.
* 디스크 스케쥴링.

#### 2.5 command interpreter의 목적은 무엇인가? 이것이 커널로부터 분리되는 이유는 무엇인가?   

* 사용자 또는 명령 파일로부터 명령을 읽고, 하나 이상의 system call로 전환하여 명령을 실행시킨다. command interpreter는 바뀔 수 있는 대상이기 때문에 일반적으로 커널의 일부가 되지 않는다.

#### 2.6 새로운 프로세스를 시작하기 위해서 command interpreter 또는 쉘이 실행해야 하는 system call은 무엇인가?
* 유닉스 시스템의 경우 새로운 프로세스를 시작하기 위해서 fork, exec system call이 연달아 호출된다. fork는 현재 실행중인 프로세스를 복제하는 것이고, exec는 다른 실행 가능한 프로세스에 새로운 프로세스를 overlay 한다.

#### 2.7 시스템 프로그램의 목적은 무엇인가?
* 시스템 프로그램은 유용한 system call의 묶음으로 생각할 수 있다. 시스템 프로그램은 사용자가 일반적인 문제를 해결하기 위해서 새로운 프로그램을 작성할 필요가 없도록 기본적인 기능을 제공한다.

#### 2.8 시스템을 설계하는데 있어서 layered approach의 장점과 단점은 무엇인가?
* modular 설계와 같은 이점을 가지고 있다. 시스템의 변화는 특정한 section에만 영향을 주기 때문에 디버그와 수정이 쉽다.
* 정보는 필요한 곳에 저장되고 지정된, 제한된 장소에서만 접근 가능하다. 이로 인해 해당 데이터에 영향을 미치는 버그는 특정 모듈 또는 layer로 한정되어야 한다.

 _(다른 위치에서 버그가 나면 문제해결이 어렵다는 이야기인듯)_

#### 2.9 os에서 제공되는 서비스 5개를 나열하고 각각이 어떻게 사용자를 편하게 만드는지 설명하라. 이 서비스들을 user-level 프로그램에 제공할 수 없는 경우는 무엇인가?
 * 프로그램 실행 - os는 파일의 내용 또는 section을 메모리에 로드하고 실행을 시작한다.

 user-level 프로그램은 cpu time을 할당하기에는 신뢰할 수 없다.

 * i/o operation - 디스크, 테이프, serial line, 그 밖의 장치들은 매우 낮은 level에서 전달되어야 한다. 사용자는 특정 장치와 장치의 동작을 위한 operation을 명시해야 한다. 시스템은 사용자의 명시를 장치 또는 controller-specific의 명령어로 전환한다.

 user-level 프로그램이 권한을 필요로 하는 장치에만 접근하거나, 사용 중이 아닌 장치에만 접근한다고 생각될 수 없다.

 * file-system manipulation - 사용자가 관여하지 않아도 되는 파일의 생성, 삭제, 할당, 이름 지정에는 많은 요소가 숨어 있다. 디스크 공간의 블록은 파일에 의해서 사용되고 반드시 관리되어야 한다. 파일을 삭제하는 것은 파일 정보를 제거하고 할당받은 블록을 반환해야 한다. 보호는 적절한 파일 접근을 보장하기 위해서 점검되어야 한다.

 사용자 프로그램은 protection method의 유지를 보장할 수 없으며, 파일 삭제시 free block을 할당하고 block을 다시 반환하는 것에 대해 신뢰 받을 수 없다.

 * 통신 - 시스템을 오가는 메세지는 정보의 패킷으로 바뀌어 network controller로 전달 되고, communications medium을 통해 전송되며, 목적지의 시스템에서 재조립 되어야 한다. 패킷의 순서화, 데이터의 보정이 일어나야 한다.

 사용자 프로그램은 네트워크 장치로의 접근을 갖추지 않았거나, 다른 프로세스로 전송될 패킷을 수신할 것이다.

 _(수동적이라는 의미겠지?)_

 * 오류 감지 - 오류 감지는 하드웨어와 소프트웨어 level에서 발생한다.

  * 하드웨어 level에서는 모든 데이터 전송은 전송 시 오류가 없도록 점검 받아야 한다. 모든 미디어 데이터는 작성된 후로 변경되지 말아야 한다.

  * 소프트웨어 level에서는 미디어 데이터는 일관성을 지켜야 한다. 예를 들어, 할당된, 반환된 저장 블록의 수는 장치의 전체 블록 수와 일치해야 한다.

 * 오류는 프로세스와는 독립적이므로(디스크 데이터의 오류와 같은) 모든 종류의 오류를 다루는 global program(os)이 필요하다. 또한 os에 의해 오류가 처리되기 때문에 프로세스는 시스템에서 발생하는 모든 오류를 잡아내고 수정하는 코드를 포함하고 있을 필요가 없다.

#### 2.10 펌웨어에 os를 저장하는 시스템과 디스크에 os를 저장하는 시스템 각각의 이유는 무엇인가?

 * PDA나 휴대폰 같은 기기의 경우, 파일 시스템이 들어 있는 디스크는 장치에 사용할 수 없을 것이다. 이런 경우 os는 반드시 펌웨어에 저장되어야 한다.

 _(음.. 설명 필요)_

#### 2.11 어떻게 부팅할 os를 선택하도록 설계될 수 있는가? bootstrap grogram은 무엇을 해야 하는가?

 * xp와 리눅스의 세 가지 배포판을 실행시키는 것을 생각하자. 각각의 os는 디스크에 저장될 것이다. 시스템이 부팅되는 동안 boot manager라 불리는 특별한 프로그램은 부팅할 os를 결절할 것이다. 이것은 부팅 초기에 os가 부팅되는 것이 아닌 boot manager가 먼저 실행되는 것을 의미한다. boot manager는 어떤 os로 부팅할 것인지 결정하는 역할을 한다. 일반적으로 boot manager는 시스템이 시작되는 동안 인지될 수 있도록 하드 디스크의 특정 위치에 존재한다. boot manager는 부팅할 시스템의 선택권을 사용자에게 제공한다. boot manager는 사용자로부터 선택된 시스템이 없다면 기본값으로 설정된 os로 부팅되도록 설계된다.
