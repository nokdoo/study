# Practice Exercises
---

#### 4.1 멀티스레딩이 single-threaded solution보다 나은 성능향상을 제공하는 세 가지 프로그래밍을 나열하라.
1. 별도의 스레드에서 각 요청에 서비스하는 웹 서버.
2. 행렬의 다른 부분이 병렬로 처리될 수 있는, 행렬 곱셈과 같은 병렬화된 어플리케이션.
3. 한 스레드가 사용자 입력에 사용되고, 다른 스레드는 실행중인 어플리케이션을 나타내고, 또 다른 스레드는 성능을 감시하는 대화형 GUI 디버깅 프로그램.

#### 4.2 user-level 스레드와 kernel-level 스레드의 두 가지 차이는 무엇인가? 어떤 상황에서 한 유형이 다른 유형보다 나은가?
1. user-level 스레드는 커널에 알려지지 않는다. 반변 커널은 커널 스레드를 알고 있다.
2. M:1 또는 M:N매핑을 사용하는 시스템에서 사용자 스레드는 스레드 라이브러리에 의해 스케쥴링 되고 커널은 커널 스레드를 스케쥴링 한다.
3. 커널 스레드는 프로세스와 관련될 필요가 없지만 모든 사용자 스레드는 프로세스에 속해 있다. 커널스레드는 kernel data structure와 함께 표현되기 때문에, 관리에 있어서는 일반적으로 사용자 스레드보다 비싸다.

#### 4.3 kernel-level thread 간 context-switch에 대한 커널의 행동을 설명하라.
일반적으로 커널 스레드간의 context-switch는 스위치되는 스레드로부터 CPU register의 값을 저장하고 스케쥴링 되는 새로운 스레드의 CPU register를 복원하는 작업을 요구한다.

#### 4.4 스레드가 생성될 때 사용되는 자원은 무엇인가? 프로세스 생성될 때 사용되는 것과는 어떻게 다른게 행동하는가?
스레드는 프로세스보다 작기 때문에, 일반적으로 스레드 생성은 프로세스 생성보다 더 적은 자원을 사용한다. 프로세스를 생성하는 것은 비교적 큰 구조인process control block(PCB)를 할당하는 것을 필요로 한다. PCB는 메모리 맵, open file 리스트, 환경 변수를 포함한다. 일반적으로 메모리 맵을 할당하고 관리하는 것은 시간을 소모하는 작업이다. 사용자 또는 커널 스레드를 생성하는 것은 register set, stack, priority를 가지기 위해 작은 data structure를 할당하는 것을 포함한다.

#### 4.5 os가 many-to-many 모델을 사용하여 user-level 스레드를 커널에 매핑하고 매핑은 LWPs를 통해서 이루어진다고 추정하자. 게다가 시스템은 개발자에게 real-time systems에서의 사용을 위해  real-time 스레드를 생성하는 것을 허용한다. real-time 스레드를 LWP에 묶는것이 필요한지 설명하라.
필요하다. real-time application에게 타이밍은 중요하다. 만일 스레드가 real-time으로 지정되고 LWP와 묶여있지 않는다면, 그 스레드는 실행 전에 LWP에 연결되기까지 기다려야 한다. real-time 스레드(LWP에 연결된)가 실행 중인지 고려하고, 그렇다면 차단을 진행한다.(즉, I/O를 수행해야 하고, 높은 순위의 real-time 스레드에 의해 선점되었으며, mutual exclusion lock을 기다린다.) real-time 스레드가 차단된 동안 연결된 LWP는 다른 스레드에 할당되었다. real-time 스레드가 다시 실행하기 위해서 스케쥴링 되었을 때, 이것은 먼저 LWP에 연결되기를 기다려야 한다. LWP를 real-time 스레드에 연결시킴으로써, 스케쥴링된 스레드를 최소한의 딜레이로 실행할 수 있다.
