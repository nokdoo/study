# 4.5 Implicit Threading
---
multicore processing의 성장으로 수백, 수천의 스레드를 포함하는 어플리케이션이 보습을 보이기 시작하고 있다. 이런 어플리케이션을 설계하는 것은 사소한 일이 아니다. 프로그래머는 4.2절에서 언급한 도전 뿐만 아니라 다른 어려움을 해결해야 한다. 프로그램의 정확도와 관련된, 이 어려움들은 5장과 7장에서 다룰 것이다.

이 어려움을 해결하고 멀티스레딩 어플리케이션 설계를 지원하는 방법은 개발자의 역할인 스레드의 생성과 관리를 컴파일러와 런타임 라이브러리에 넘기는 것이다. 이 암묵적 스레딩 전략은 최근의 인기있는 트렌드이다. 이번 절에서는 암묵적 스레딩을 통해 multicore processor의 이점을 가질 수 있는, 멀티스레딩 프로그램을 설계하는 세 가지 접근에 대해 알아볼 것이다.

## The JVM and The HOST OPERATING SYSTEM
JVM은 일반적으로 host os의 top에서 구현된다[Figure 16.10, p737]. 이 설정은 JVM이 하단(underlying) os의 세부 구현을 숨길 수 있게 하고, JVM을 지원하는 어떤 플랫폼에서도 자바 프로그램이 동작하는 일관되고 추상적인 환경을 제공하도록 한다. JVM을 위한 명세는 어떻게 자바 스레드가 하단(underlying) os에 매핑되는지를 나타내지 않고, 대신 JVM의 특정 구현을 위한 결정을 남긴다. 예를 들어, Windows XP os는 one-to-one 모델을 사용하는데, 이런 시스템에서 실행되는 JVM에 대한 각 자바 스레드는 커널 스레드에 매핑된다. many-to-many 모델을 사용하는 os(Tru64 UNIX와 같은)에서 각 자바 스레드는 many-to-many 모델에 따라 매핑된다. 초기의 솔라리스는 many-to-one 모델을 사용해서 JVM을 구현했다(일찍이 언급한, green thread library). 이후의 JVM 버전은 many-to-many 모델을 사용해서 구현됐다. 솔라리스 9의 시작과 함께, 자바 스레드는 one-to-one 모델을 사용해서 매핑되었다. 추가적으로, 자바 스레드 라이브러리와 host os의 스레드 라이브러리는 서로 관계가 있을 것이다. 예를 들어, Windows 시리즈에 대한 JVM의 구현은 자바 스레드를 생성할 때 Windows API를 사용할 것이다. 리눅스, 솔라리스, Mac OS X 시스템에서는 Pthreads API를 사용할 것이다.
