# 4.6 Threading Issues
---
이번 절에서는 멀티스레딩 프로그램 설계에서 고려해야하는 몇 가지 이슈를 다룬다.

## 4.6.1 The fork() and exec() System calls
---
3장에서 별도로 복제된 프로세스를 생성하는데 `fork()` system call이 어떻게 사용되는지 알아보았다. `fork()`와 `exec()` system call의 semantic은 멀티스레딩 프로그램에서 바뀐다.

프로그램에서 한 스레드가 `fork()`를 호출한다면, 새로운 프로세스는 모든 스레드를 복제하는가? 또는 새 프로세스는 single-threaded인가? 어떤 UNIX 시스템은 `fork()`의 두 가지 버전을 선택했다. 하나는 모든 스레드를 복제하는 것이고 다른 하나는 `fork()` system call을 호출한 스레드만을 복제하는 것이다.

`exec()` system call은 일반적으로 3장에서 설명한 방식으로 동작한다. 만일 스레드가 `exec()` system call을 호출하면 파라미터에 명시된 프로그램은 모든 스레드를 포함하여 전체 프로세스를 대체할 것이다.

`fork()`의 두 가지 버전 중 어느것을 사용할 지는 어플리케이션에 달려있다. `exec()`가 포킹 후 즉시 호출된다면 모든 스레드를 복제하는 것이 필요하지 않다. `exec()` 파라미터에 명시된 프로그램이 전체 프로세스를 대체하기 때문이다. 이런 경우, 호출하는 스레드만을 복제하는 것이 적절하다. 반대로 별도의 프로세스가 포킹 후 `exec()`를 호출하지 않는다면 그 프로세스는 모든 스레드를 복제해야 한다.

## 4.6.2 Single Handling
---
UNIX 시스템에서는 특정 이벤트가 발생했음을 프로세스에 알리기 위해서 signal이 사용된다. signal은 signal가 되는 이벤트의 발생 이유와 출처에 따라 synchronously 또는 asynchronously하게 수신될 수 있다. 모든 signal는 synchronously 또는 asynchronously에 관계없이 다음의 패턴을 따른다.

1. signal은 특정 이벤트의 발생에 의해서 생성된다.
2. signal은 프로세스로 전달된다.
3. 전달된 signal은 handle 되어야 한다.

synchronous signal은 0으로 나누기, illegal memory access를 포함한다. 실행중인 프로그램이 이 행동을 취한다면 signal이 생성된다. synchronous signal은 신호를 발생시킨 operation을 수행한 프로세스에 전달된다(synchronous로 간주되었기 때문).

실행 중인 프로세스 외부의 이벤트에 의해 signal이 생성될 때, 프로세스는 asynchronously으로 signal을 받는다. asynchronously signal은 명시된 keystroke(ctr+c)나 시간 만기로 프로세스가 종료되는 것을 포함한다. 일반적으로 asynchronous signal은 다른 프로세스로 보내진다.

signal은 다음 두 핸들러 중 하나에 의해 handle된다.

1. 기본 signal handler
2. 사용자 정의 signal handler

모든 signal은 해당 signl를 handle할 때 커널이 실행하는 default dignal handler를 가지고 있다. 이 기본 동작은 signal을 handle하기 위해 호출되는 user-defined signal handler에 의해 덮어씌워질 수 있다. signal은 다른 방법으로 handle된다. 어떤 signal은(창의 크기를 바꾸는 것과 같은) 간단히 무시된다. 이 밖의 signal은(illegal memory access 같은) 프로그램을 종료하는 것에 의해 handle된다.

single-threaded program에서 signal을 handle하는 것은 직관적이다. signal은 항상 프로세스로 전달된다. 하지만 프로세스가 여러 스레드를 가지고 있는 multithreaded program에서 signal을 전달하는 것은 복잡하다. 그러면 signal은 어디에 전달되어야 하는걸까?

일반적으로 네 개의 선택이 존재한다.

1. signal이 적용되는 스레드에 전달한다.
2. 프로세스의 모든 스레드에 전달한다.
3. 프로세스의 특정 스레드에 전달한다.
4. 프로세스에 대한 모든 signal을 받을 명시적 스레드를 지정한다.

signal 전달을 위한 메소드는 생성된 signal의 타입에 의존한다. 예를 들어 synchronous signal은 signal을 프로세스의 다른 스레드가 아닌 일으키는 스레드에 전달되어야 한다. 하지만 asynchronous signal가 있는 상황은 명확하지 않다. 어떤 asynchronous signal(프로세스를 종료하는 ctr+c 같은)은 모든 스레드에 전달되어야 한다.

signal 전달을 위한 표준 UNIX 함수는

    kill(pid_t pid, int signal)

이다. 이 함수는 특정 signal이 전달되는 프로세스(pid)를 명시한다. UNIX의 멀티스레딩 버전 대부분은 스레드가 signal을 수용할지 차단할지 명시할 수 있도록 한다. 그러므로, 어떤 경우에는 asynchronous signal이 수용된 스레드에만 전달될 수 있다. 그러나 signal은 한 번만 handle되어야 하기에 일반적으로 차단되지 않은 스레드 중 첫 번째로 발견한 스레드에만 전달된다. POSIX Pthreads는 signal이 명시된 스레드(tid)로 전달되도록 하는 다음의 함수를 제공한다.

    pthread_kill(pthread_t tid, int signal)

Windows는 signal을 명시적으로 지원하지 않지만 asynchronous procedure calls (APCs)를 사용해서 signal을 emulate할 수 있게 한다. APC facility는 사용자 스레드가 특정 이벤트의 알림을 받았을 때 호출되는 함수를 명명하기 위해 사용자 스레드를 이용할 수 있다. 이름대로 APC는 UNIX의 asynchronous signal과 거의 동일하다. 하지만 UNIX는 멀티스레딩 환경에서 signal을 어떻게 다루어야 하는지 고민하는 반면, APC facility는 프로세스가 아닌 특정 스레드에 전달되기 때문에 더 직관적이다.

## 4.6.3 Thread Cancellation
---
thread cancellation은 스레드가 완료되기 전에 종료하는 것을 포함한다. 예를 들어 multiple thread가 동시에 데이터베이스를 탐색하고 한 스레드가 결과를 반환한다면 남아 있는 스레드는 아마 취소될 것이다. 다른 상황은 사용자가 웹 브라우저에서 페이지 로딩 중지 버튼을 누를 때 발생할 수 있다. 종종 웹 페이지는 여러 스레드를 이용해서 로드한다(각 이미지는 별도의 스레드에 로드된다.). 사용자가 브라우저에서 중지 버튼을 누를 때 페이지를 로드하고 있던 모든 스레드는 중지된다.

취소될 스레드는 종종 target thread로서 참조된다. target thread의 cancellation은 두 가지 다른 상황에서 발생할 수 있다.

1. Asynchronous cancellation - 한 스레드는 즉시 target thread를 종료한다.
2. Deferred cancellation - target thread는 주기적으로 종료되어야 하는지를 확인하고 순서대로 자신을 종료하는 기회를 부여한다.

cancellation의 어려움은, 자원이 취소된 스레드에 할당되었거나 스레드가 다른 스레드와 공유중인 데이터를 업데이트 하는 도중에 최소되었을 때 발생한다. 이것은 특히 asynchronous cancellation와 귀찮은 문제가 된다. 종종 os는 취소된 스레드로부터 시스템 자원을 정리하지만 모든 자원을 정리하지는 않는다 그러므로 스레드를 asynchronously하게 취소하는 일은 필요한 system-wide resource를 확보할 수 없다.
