# 3.6.1 Sockets
---
소켓은 통신의 end point로 정의된다. 네크워크를 통해 통신하는 프로세스의 쌍은 각각 프로세스에 대한 소켓 쌍을 제공한다. 소켓 포트 번호가 포함된 ip로 식별 가능하다. 일반적으로 소켓은 client-server 아키텍처를 사용한다. 서버는 명시된 포트를 주시하며 클라이언트의 요청을 기다린다. 요청을 받고 나면, 서버는 클라이언트 소켓이 연결을 완성하는 것을 허용한다. 서버는 각각 23, 21, 80의 포트를 가진 telnet, FTP, HTTP와 같은 특정 서비스를 구현하고 있고, 이 포트를 주시하고 있다. 이처럼 잘 알려진 포트는 1024보다 낮은 값을 가지고 있고, 표준 서비스를 구현하기 위해 사용된다.

클라이언트 프로세스가 연결을 위한 요청을 초기화할 때, 클라이언트 프로세스는 호스트 컴퓨터로부터 포트를 할당 받는다. 이 포트는 1024보다 큰 임의의 숫자다. 예를 들어, 146.86.5.20의 ip를 가진 호스트 X의 클라이언트가 ip 161.25.19.8의 웹서버와 연결을 형성하고자 한다면, 호스트 X는 1625의 포트를 할당한다. 이 연결은 호스트 X의 146.86.5.20:1625, 웹 서버의 161.25.19.8:80 소켓 쌍을 구성할 것이다. 이 상활은 [Figure 3.20, p137]에 설명되어 있다. 호스트 사이를 이동하는 패킷은 목적지 포트 번호에 맞는 적절한 프로세스로 전달된다.

모든 연결은 유일하다. 그러므로, 호스트 X의 다른 프로세스가 같은 웹 서버와의 다른 연결을 시도했다면, 이 프로세스는 1024보다는 크고 1625는 아닌 포트 번호를 할당 받을 것이다. 이것은 모든 연결이 유일한 소켓 쌍으로 구성되는 것을 보장한다.

이 책에서는 C를 사용해서 대부분의 프로그램을 설명하지만, 소켓은 Java를 이용해서 설명한다. Java가 소켓에 대한 쉬운 인터페이스를 제공하고, 네트워크 유틸리티에 대한 풍부한 라이브러리를 제공하기 때문이다. C나 C++에서의 소켓 프로그래밍은 이 장 마지막의 참고문헌을 참고하도록 한다.

Java는 세 가지 다른 소켓 타입을 제공한다. 소켓 클래스로 구현된 Connection-oriented(TCP) Sockets, DatagramSocket 클래스를 사용하는 Connectionless(UDP) Sockets, DatagramSocket의 subclass인 MulticastSocket 클래스다. MulticastSocket은 데이터가 다수의 수신자에게 보내지는 것을 허용한다.

예시로 Connection-oriented TCP Sockets을 사용하는 data server를 설명한다. operation은 클라이언트가 서버에게 현재 날짜와 시간을 요철할 수 있도록 한다. 서버는 포트 6013을 주시한다. 서버가 연결을 수신하면 클라이언트에 날짜와 시간을 반환한다.

날짜 서버는 [Figure 3.21, p138]에서 설명되었다. 서버는 앞으로 주시할 포트 6013을 명시하는 ServerSocket을 생성한다. 서버는 accept() 메서드로 포트 6013을 주시하고 클라이언트 요청을 기다리며 차단된다. 이후에 연결 요청을 받으면 accept()는 클라이언트와 통신할 수 있는 소켓을 반환한다.

소켓과 서버가 어떻게 통신할까? 서버는 먼저 클라이언트와의 통신에 사용할 PrintWriter object를 생성한다. PrintWriter object는 서버가 출력을 위해서 일상적인 print(), println() 메서드를 사용해서 소켓에 write를 허용한다. 서버 프로세스는 클라이언트에 날짜를 보내고 println() 메서드를 호출한다. 소켓에 날짜를 write하면 서버는 클라이언트와의 소켓을 끊고 다른 요청을 주시하는 상태로 되돌아간다.

클라이언트는 소켓을 생성하고 서버가 주시하고 있는 포트에 연결해서 서버와 통신한다. [Figure 3.22, p139]에 Java로 클라이언트가 구현되었다. 클라이언트는 127.0.0.1:6013 서버와의 소켓을 생성하고 연결을 요청한다. 연결이 만들어지면 클라이언트는 일반 stream I/O statements를 사용해서 소켓으로부터 날짜와 시간을 읽어올 수 있다. 서버로부터 날짜를 받은 후에 클라이언트는 소켓을 닫고 빠져나온다. 127.0.0.1은 loopback으로 알려진 특별한 ip이다. 컴퓨터가 ip 127.0.0.1를 참조하면 자신을 참조하게 된다. 이 메커니즘은 같은 호스트에서 클라이언트와 서버가 TPC/IP프로토콜을 이용해서 통신할 수 있게 한다. ip뿐 아니라 www.westminstercollege.edu와 같은 호스트 이름 또한 사용이 가능하다.

일반적이고 효율적인 소켓을 사용하는 통신은 분산 프로세스 통신의 low-level로 간주된다. 한 가지 이유는 소켓이 통신 스레드 사이에서 교환되는 구조화되지 않은 bytes stream만 허용한다는 것이다. 데이터의 구조를 형성하는 것은 클라이언트 또는 서버 어플리케이션의 역할이다. 다음 두 절에서 두 가지 higher-level의 통신 방법인 remote procedure calls(RPCs)와 pipes를 살펴볼 것이다.
