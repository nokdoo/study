# 3.6.2 Remote Procedure Calls
---
원격 서비스의 일반적인 형태 중 하나는 3.5.2 절에서 간략히 논의한 RPC 패러다임이다. RPC는 네트워크 통신 시스템에서 사용하기 위해 procedure-call 메커니즘을 추상화하는 방법으로서 설계되었다. RPC는 3.4절에서 설명한 IPC 매커니즘과 많은 부분이 비슷하다. 그리고 일반적으로 시스템의 상단에서 만들어진다. 하지만 지금은 분리된 시스템에서 실행되는 프로세스에서 실행되는 환경을 다루고 있기 때문에, 원격 서비스를 제공하기 위해서 message-based communation shceme를 사용해야 한다.

IPC 메세지와는 대조적으로, RPC 통신에서 교환된 메세지는 잘 설계 되어 더 이상 데이터의 패킷이 아니다. 각 메세지는 원격 시스템의 포트를 주시하는 RPC 데몬으로 보내지고 식별자를 포함한다. 식별자는 실행을 위한 함수와 이 함수에 보내지는 파라미터를 명시한다. 함수는 요청 받은대로 실행되고, 출력은 별개의 메세지로 요청자에게 보내진다.

포트는 메세지 패킷의 시작위치에 포함된 숫자다. 시스템은 보통 하나의 네트워크 주소를 갖는 반면, 지원하는 많은 네트워크 서비스을 구별하기 위해서 주소안에 많은 포트를 가지고 있다. 원격 프로세스가 서비스를 원한다면 프로세스는 적절한 포트로 메세지를 전달할 것이다. 예를 들어 한 시스템이 다른 시스템에게 현재 사용자 목록을 이용할 수 있게 하고 싶다면, 시스템은 포트에 연결된 RPC와 같은 것을 지원하는 데몬을 가지고 있을 것이다. 서버 포트에 RPC 메세지를 보냄으로서 원격 시스템은 필요한 정보를 얻을 수 있다. 데이터는 응답 메세지로 받아진다.

RPCs의 semantic은 클라이언트가 원격 호스트의 프로시저를 로컬에서 호출하는 것처럼 보이게 할 수 있다. RPC 시스템은 통신을 허용하는 세부 정보를 숨기는데, 세부 정보는 클라이언트 영역에 stub을 제공함으로써 통신을 이룬다. 일반적으로 분리된 stub은 분리된 각 원격 프로시저에 대해 존재한다. 클라이언트가 원격 프로시저를 호출할 때, RPC 시스템은 적절한 stub을 호출하고 원격 프로시저에 제공된 파라미터를 stub에 넘겨준다. 이 stub은 서버의 포트에 위치하고 파라미터를 통제한다(marshal). 파라미터 마셜링은 파라미터를 네트워크를 통해 전솔될 수 있는 형태로 패키징하는 것을 포함한다. 그러면 stub은 message passing을 이용해서 메세지를 서버에 전송하게 된다. 서버 영역의 유사한 stub은 이 메세지를 받고 서버의 프로시저를 호출한다. 필요하다면 같은 방식으로 클라이언트에 반환값이 전달된다. 윈도우즈 시스템에서 stub 코드는 Microsoft Interface Definition Language(MIDL)에 정의된대로 컴파일 된다. MIDL은 클라이언트와 서버 프로그램 간의 인터페이스를 정의하는데 사용된다.

다루어야 할 한 가지 이슈는 클라이언트와 서버 machine간의 데이터 표현의 차이점에 관심을 가지는 것이다. 32비트 정부의 표현을 생각하자. big-endian으로 알려진 시스템은 MSB를 우선 저장하는 반면, little-endian으로 알려진 시스템은 LSB를 먼저 저장한다. 순서는 중요하지 않다. 오히려 순서의 선택은 컴퓨터 아키텍처 내에서 임의적으로 이루어진다. 이 차이점을 해결하기 위해서 만은 RPC 시스템들은 machine-independent data 표현을 정의한다. 표현의 한 가지는 external data representation (XDR)이다. 클라이언트 영역에서 파라미터 마셜링은 machine-dependent data가 서버로 보내지기 전에 XDR로 변환한다. 서버 영역에서는 XDR 데이터가 언마셜되고 서버에 대한 machine-dependent로 표현으로 변환된다.

다른 중요한 이슈는 호출의 semantic을 포함한다. 로컬 프로시저는 극단적인 상황에서만 호출이 실패하는 반면, RPC는 일반적인 네트워크 오류의 결과로 실패하거나 중복되어 두 번 실행될 수 있다. 이 문제를 다루기 위한 한 가지 방법은, os가 메세지를 최대 한 번이 아닌 정확히 한 번 수행하도록 보장하는 것이다. 대부분의 로컬 프로시저는 정확히 한번 수행되지만 이를 구현하기가 어렵다.

최대 한 번 수행하는 것을 생각해보자. 이 semantic은 각 메세지에 타임스탬프를 추가한다. 서버는 이미 처리된 모든 메세지 타임스탬프의 히스토리이나, 메세지의 반복을 감지하기 위한 큰 히스토리를 가지고 있어야 한다. 히스토리에 이미 타임스탬프를 가지고 있는, 들어오는 메세지는 무시된다. 그러면 클라이언트는 메세지를 한 번 이상 보낼 수 있고 메세지가 한 번만 실행되도록 보장한다.

정확히 한 번 수행하는 것에 대해서는, 서버가 요청을 받지 않게 되는 위험을 제거할 필요가 있다. 이를 위해서 서버는 위에서 설명한 '최대 한 번' 프로토콜을 구현해야 하면서도, 클라이언트가 RPC를 수신하고 실행하였는지 인지해야 한다. 이 ACK 메세지는 네트워킹 분야에서 보편적이다. 클라이언트는 각 RPC 호출에 대해 ACK를 받을 때까지 주기적으로 응답하여야 한다.

또 다른 중요한 이슈는 서버와 클라이언트 통신에 관한 것이다. 링크, 로드, 실행 시간동안, 표준 프로시저 호출과 함께 바인딩의 형태가 발생한다(8장). 이는 프로시저 호출의 이름이 프로스지 호출의 메모리 주소로 대체 되기 위함이다. RPC 스키마는 클라이언트와 서버 포트와 유사한 바인딩을 요구하지만, 클라이언트가 서버의 포트 번호를 어떻게 알 수 있을까? 시스템들은 메모리를 공유하고 있지 않기 때문에 다른 시스템의 모든 정보를 가지고 있지 않다.

두 개의 접근이 일반적이다. 첫 번째는 정보를 바인딩 하는 것은 고정된 포트 주소의 형태로 미리 결정될 수 있다. 컴파일 시간에 RPC 호출은 앞의 포트 주소와 결합된 고정된 포트 번호를 가지고 있는다. 프로그램이 컴파일 되면 서버는 요청 받은 서비스의 포트 번호를 바꿀 수 없다. 두 번째로, 바인딩이 rendezvous 메커니즘에 의해 동적으로 수행될 수 있다. 일반적으로 os는 고정 RPC포트의 rendezvous(matchmaker라고도 불리는) 데몬을 제공한다. 그러면 클라이언트는 TPC의 이름을 포함한 메세지를 RPC의 포트 주소를 요청하는 rendezvous 데몬 *** 포트 번호는 반환되고, 프로세스가 종료될 때까지(또는 서버에 충돌이 발생할 때까지) RPC 호출이 반한된 포트로 전송될 수 있다. 이 방법은 요청을 초기화하는 추가적인 오버헤드를 필요로 하지만 첫 번째 방법보다는 더 유연하다. [Figure 3.23, p141]은 예를 보여준다.

RPC 스키마는 분산 파일 시스템을 구현하는데 유용하다(17장). 이런 시스템은 RPC 데몬과 클라이언트의 집합으로서 구현될 수 있다. 메세지는 분산 파일 시스템 포트에 전달된다. 이 포트는 파일 operation이 생성되는 서버에 위치한다. 디스크 operation은 파일과 관련된 보통의 system call에 해당하는 read, write, rename, delete, status가 될 수 있다. 반환된 메세지는 클라이언트를 대신하는 DFS 데몬에 의해 실행되는 호출로 생성되는 데이터를 포함한다. 예를 들어, 메세지는 전체 파일을 클라이언트로 전송하기 위한 요청을 가지고 있거나, 간단한 블록 요청으로 한정될 수 있다. 후자의 경우, 전체 파일이 전송되어야 한다면 일부 요청이 요구될 수 있다.
