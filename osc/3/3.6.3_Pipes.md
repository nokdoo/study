# 3.6.3 Pipes
---

파이프는 두 개의 프로세스를 통신할 수 있게 하는 도관처럼 움직인다. 파이프는 초기 유닉스 시스템의 IPC 메커니즘 중 하나이다. 파이프에는 약간의 제약이 있지만, 일반적으로 프로세스 간 통신의 더 간단한 방법을 제공한다. 파이프 구현에서 네 가지 이슈가 고려되어야 한다.

1. 파이프가 양방향 통신을 지원하는가? 또는 통신이 단방향인가?
2. 양방향 통신이 허용된다면 파이프는 half duplex(데이터가 한 번에 한 방향만 전송되는)인가? full duplex(데이터가 동시에 양방향 전송되는)인가?
3. parent-child같은 관계가 통신 프로세스 간에 존재해야 하는가?
4. 파이프는 네트워크를 통해서 통신할 수 있는가? 아니면 통신 프로세스는 같은 machine에 위치해야 하는가?

다음 절에서 유닉스와 윈도우즈 시스템에서 사용되고 있는 두 가지 형태의 파이프, ordinary pipes, name pipes에 대해 알아본다.


## 3.6.3.1 Ordinary Pipes
---

Ordinary pipes는 두 개의 프로세스가 standard producer-consumer fashion으로 통신하도록 한다. producer는 파이트의 한쪽 끝에 작성하고(write-end) consumer는 반대쪽 끝에서부터 읽는다(read-end). 결과적으로 ordinary pipes는 단방향 통신이다. 만일 양방향 통신이 필요하다면 서로 다른 방향을 가진 두 개의 파이프가 사용되어야 한다. 곧 유닉스와 윈도우즈 시스템에서 ordinary pipes를 구축하는것을 설명할 것이다. 두 프로그램의 예제에서, 한 프로세스는 Greetings 메세지를 파이프에 작성하고 다른 한 프로세스는 파이프로부터 메세지를 읽는다.

유닉스 시스템에서 ordinary pipes는

    pipe(int fd[])
함수를 사용해서 구축되었다.

이 함수는 `int fd[]` 파일 디스크립터를 통해 접근 가능한 파이프를 생성한다. `fd[0]`은 파이프의 read-end이고 `fd[1]`은 write-end이다. 유닉스는 파이프를 특별한 파일로 다룬다. 그러므로 파이프는 ordinary `read()`와 `write()` system call을 사용해서 접근될 수 있다. ordinary pipe는 이것을 생성한 외부 프로세스가 접근할 수 없다. 일반적으로 부모 프로세스는 하나의 파이프를 생성하고 이것을 `fork()`를 통해 생성된 자식 프로세스와 통신하기 위해 사용한다. 3.3.1절의 자식 프로세스는 부모의 open file을 상속받는 다는 것을 기억하라. 파이프가 특별한 파일이기 때문에 자식은 부모 프로세스로부터 파이프를 상속 받는다. [Figure 3.24, p143]은 부모와 자식 프로세스와 파일 디스크립터 `fd`의 관계를 설명한다.

유닉스 시스템 프로그램은 [Figure 3.25, p143]에서 보여진다. 부모 프로세스는 파이프를 생성하고 자식 프로세스를 생성하는 `fork()` 호출을 전송한다. `fork()` 호출을 하고 생성되는 것은 데이터가 파이프를 통해서 어떻게 전달되는지에 의존한다. 이런 경우 부모 프로세스는 파이프에 write하고 자식 프로세스는 파이프로부터 read한다. 처음에 부모 프로세스와 자식 프로세스가 파이프의 사용되지 않는 end를 닫는 것을 알고 있어야 한다. [Figure 3.25, p143]에서 프로그램이 이런 행동을 필요로 하지는 않지만, writer가 파이프의 끝을 닫았을 때 파이프를 읽는 프로세스가 파일의 끝을 감지하는 것을(`read()`가 0을 반환하는 것을) 보장하는 것은 중요한 단계이다.

윈도우즈 시스템의 ordinary pipes는 anonymous pipes로 명명되었다. 이것은 유닉스와 비슷하다. 프로세스간 통신에 단방향과 parent-child관계를 이용한다. 여기에 추가적으로 파이프를 읽거나 쓰는 것이 ordinary `ReadFile()`과 `WriteFile()` 함수를 통해 완성될 수 있다. 파이프를 생성하는 윈도우즈 API는 네 가지 파라미터를 사용하는 `CreatePipe()` 함수이다. 파라미터는 파이프에 읽기(1), 쓰기(1)를 위한 별도의 핸들을 제공하고, 자식 프로세스가 파이프의 핸들을 상속할 것을 명시하기 위해 사용되는 `STARTUPINFO` structure의 인스턴스(3) 또한 제공한다. 여기에 파이프의 크기(4)가 명시될 수 있다.

[Figure 3.27, p145]은 자식 프로세스와의 통신을 위해 anonymous pipe를 생성하는 부모 프로세스를 설명한다. 자식 프로세스가 부모 프로세스에 의해 생성된 파이프를 자동적으로 상속하는 유닉스 시스템과는 다르게, 윈도우즈에서는 프로그래머가 파직 프로세스가 상속할 것에 대한 속성을 명시할 것을 요구한다. 이것은 파이프의 read, write에 대한 표준 입력을 위해서, 핸들이 상속받고 자식 프로세스의 핸들을 redirecting하는 것을 허용하기 위해 우선 `SECURITY_ATTRIBUTES` structure를 초기화 하는 것에 의해 완성된다. 자식 프로세스는 파이프로부터 읽을 것이고, 부모 프로세스는 자식 프로세스의 파이프 read 핸들을 redirect 해야한다. 게다가 파이프는 half duplex이기에, 자식 프로세스가 파이프의 write-end를 상속하는 것을 금지하는 것이 필요하다. 자식 프로세스를 생성하기 위한 프로그램은, 자식 프로세스가 부모에 의해 설계된 핸들을 상속하는 것을 암시하는 다섯 번째 파라미터가 `TRUE`로 되었다는 것을 제외하면 [Figure 3.11, p120]과 유사하다. 파이프에 write하기 전에, 부모 프로세스는 자신의 사용하지 않는 파이프의 read-end를 닫는다. 파이프를 읽는 자식 프로세스는 [Figure 3.29, p147]에서 보여준다. 파이프를 read하기 전에 프로 그램은 `GetStdHandle()` 호출을 통해 파이프에 대한 read 핸들을 얻는다.

유닉스와 윈도우즈 시스템에서 ordinary pipes는 통신하는 프로세스간의 parent-child 관계를 필요로 한다. 이것은 파이프가 오직 같은 machine의 프로세스 간 통신을 위해 사용되는 것을 의미한다.

## 3.6.3.2 Named Pipes
---
ordinary pipes는 프로스세 쌍이 통신하는 간단한 메커니즘을 제공하지만, 한 프로세스가 다른 프로세스와 통신하는 동안에만 존재한다. 유닉스와 윈도우즈 시스템에서 프로세스가 통신을 끝내고 종료하면 ordinary pipe는 중단된다.

Named pipes는 더 많고 강력한 통신 툴을 제공한다. 양방향 통신이 가능하고 parent-child 관계가 필요하지 않다. named pipe가 성립되면 몇몇 프로세스는 통신을 위해서 이를 사용할 수 있다. 일반적으로 named pipe는 몇개의 writer를 가진다. 추가적으로 named pipe는 프로세스 간 통신이 종료된 후에도 계속 존재한다. 구현의 디테일은 크게 다를지라도 유닉스와 윈도우즈 시스템 모두 named pipes를 제공한다. 다음에서 각 시스템에서의 named pipes를 살펴본다.

유닉스 시스템에서 named pipes는 FIFO로 참조된다. 생성되고 나면 파일 시스템의 형식적인 파일로 나타난다. FIFO는 `mkfifo()` system call로 생성되고, `open()`, `read()`, `write()`, `close()` system call 로 조작된다. 이것은 파일 시스템으로부터 명지석으로 제거될 때까지 존재한다. FIFO는 양방향 통신이 가능하지만 half-duplex만 허용된다. 데이터가 양방향으로 전송된다면 두 개의 FIFO가 사용된다. 추가적으로 프로세스 통신은 같은 machine에 위치해야 한다. 기계 간 통신이 필요하다면 3.6.1절의 소켓이 사용되어야 한다.

윈도우즈 시스템에서 named pipes는 유닉스 보다 풍부한 통신 메커니즘을 제공한다. full-duplex 통신이 허용되고, 프로세스 간 통신이 같은 또는 다른 machine에 위치할 것이다. 추가적으로 byte-oriented 데이터만이 유닉스 FIFO를 통해서 전송될 것이다. 유닉스에서는 byte-oriented 데이터만 전송되는 반면, 윈도우즈 시스템에서는 byte-oriented, message-oriented 데이터 모두 전송 된다. named pipe는 `CreateNamedPipe()` 함수를 통해 생성되고 클라이언트는 `ConnectNamedPipe()`를 사용해서 named pipe에 연결할 수 있다. named pipe을 통한 통신은 `ReadFile()`, `WriteFile()` 함수를 통해서 완성될 수 있다.
