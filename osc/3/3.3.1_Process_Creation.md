# 3.3.1 Process Creation
---
실행 단계에서 프로세스는 추가적인 프로세스를 생성한다. 언급했듯이 프로세스를 생성하는 것은 부모 프로세스, 생성된 프로세스는 자식 프로세스라고 한다. 생성된 프로세스는 다른 프로세스를 차례로 생성하고 프로세스의 tree를 형성한다.

유닉스, 리눅스, 윈도우즈를 포함하는 대부분의 os는 process identifier(pid)에 따라 프로세스를 구별한다. pid는 시스템의 각 프로세스에 대한 특별한 값을 제공하고 커널 내 프로세스의 다양한 속성에 접근하기 위한 인덱스로 사용될 수 있다.

[Figure 3.8, p116]은 리눅스에 대한 보통의 프로세스 트리이다. 이는 각 프로세스의 이름과 pid를 보여준다. 항상 1의 pid 값을 가지는 init 프로세스는 모든 사용자 프로세스에 대한 root parent process의 역할을 한다. 시스템이 부팅되면, init 프로세스는 웹 서버, 프린터 서버, ssh 서버 등 다양한 사용자 프로세스를 생성한다. kthreadd 프로세스는 커널(이 경우에는 khelper, pdflush)을 대신해서 새 프로세스의 생성을 담당한다. sshd 프로세스는 ssh(secure shell)을 사용해서 시스템에 접근하는 클라이언트를 관리한다. 로그인 프로세스는 시스템에 직접 로그온 하는 클라이언트를 관리한다. 예를 들어서(그림 참조) 클라이언트가 로그온 하고 bash shell을 사용하는 프로세스는 8416의 pid 값이 할당 되었다. 사용자는 bash command-line interface를 사용하여 ps와 emacs editor 프로세스를 생성 했다.

유닉스와 리눅스에서는 ps 명령어를 사용해서 프로세스 리스트를 얻을 수 있다. _ps -el_ 명령어를 입력하면 시스템엣 현재 실행중인 모든 프로세스에 대한 정보를 얻을 수 있다. [Figure 3.8, p116]처럼 반복적으로 부모 프로세스를 추적하여 init 프로세스에 도달하는 프로세스를 생성하는 것은 쉬운 일이다.

일반적으로 프로세스가 자식 프로세스를 생성할 때, 자식 프로세스는 task를 수행하기 위해서 cpu time, memory, files, i/o devices 같은 특정 자원을 필요로 할 것이다. 자식 프로세스는 필요한 자원을 os로부터 얻거나, 부모 프로세스의 일부 자원만으로 제한될 수 있다. 부모 프로세스는 자원의 일부를 자식 프로세스에 분배하거나 memory나 file같은 자원의 일부를 공유할 수 있다. 부모 프로세스의 자원에 자식 프로세스를 제한하는 것은, 너무 많은 자식 프로세스를 생성해서 시스템에 과부하를 주는 것을 방지하기 위함이다.

부모 프로세스는 물리적인, 논리적인 지원 말고도 자식 프로세스에 초기화 데이터를 전달한다. 예를 들어 터미널 화면에 이미지 파일의 내용을 보여주는 프로세스를 생각하자. 자식 프로세스가 생성될 때 부모로부터 입력으로 파일의 이름을 가져온다. 자식 프로세스는 이 파일의 이름을 이용해서 파일을 열고 내용을 작성한다. 이름은 출력 장치에 대해서도 사용할 수 있다. 어떤 os는 자식 프로세스에 자원을 전달한다. 이런 시스템에서는 자식 프로세스는 열려있는 이미지, 터미널 파일을 얻을 수 있고 이들 사이에 datum(뜻:하나의 자료)를 간단히 전송할 수 있다.

프로세스가 새 프로세스를 생성할 때 실행에 대한 두 가능성이 존재한다.
1. 부모 프로세스는 자식 프로세스와 함께 동시에 실행된다.
2. 부모 프로세스는 자식 프로세스가 일부 또는 전부 종료될 때까지 기다린다.

새 프로세스에 대한 두 address-space 가능성이 있다.
1. 자식 프로세스는 부모 프로세스의 복제판이다. 부모 프로세스와 같은 프로그램과 데이터를 가진다.
2. 자식 프로세스에 새 프로그램이 로드된다.

이 차이점을 설명하기 위해서 유닉스 os을 생각해보자. 지금까지 보아왔듯이 유닉스의 각 프로세스는 pid에 의해 구별된다. 새 프로세스는 fork() system call에 의해 생성된다.

    [Figure 3.9, p118]에서 볼 수 있는 if{}else if{}else 구문은 하나의 분기만 진행되지 않는다. fork()를 실행하면 프로그램이 복제되어 메모리에서 실행되는데, 각 프로세스가 실행되어 부모 프로그램은 0보다 큰 정수, 자식 프로그램은 0인 경우를 처리하게 된다.

새 프로세스는 원본 프로세스의 address-space의 복제로 구성되어 있다. 이 메커니즘은 부모 프로세스가 자식 프로세스와 통신하는 것을 쉽게 만든다. 두 프로세스는 fork() 다음의 instruction을 계속 실행한다. 이 둘의 차이점은, fork()에 대한 리턴 값이 자식 프로세스는 0, 부모 프로세스는 자식 프로세스의 pid값이 리턴된다는 것이다.

fork() system call 후에 두 프로세스 중 한 프로세스의 메모리 공간을 새로운 프로그램으로 대체하기 위해서 exec() system call을 사용한다. exec() system call은 바이너리 파일을 메모리에 로드하고(exec() system call을 포함하는 프로그램의 메모리 이미지를 파괴 - _기존의 메모리를 파괴한다는 의미인듯_) 실행을 시작한다. 이 방법으로 두 프로세스는 통신할 수 있고 다른 방향으로 이동할 수 있다. _(뜬금없이 이 방법에 의해 통신과 이동을 할 수 있다니?)_ 부모 프로세스는 더 많은 자식 프로세스를 생성할 수 있다. 자식 프로세스가 동작하는 동안 아무것도 하지 않는다면, wait() system call을 이용하여 자식 프로세스가 종료될 때까지 자신을 ready queue에서 제외시킨다. 프로세스의 address-space가 새로운 프로그램으로 overlay되기 때문에 exec() system call은 에러가 발생하지 않는 한 제어권을 반환하지 않는다.

[Figure 3.9, p118]의 c 프로그램은 앞서 설명했었던 유닉스 system call을 보여준다. 지금 우리는 같은 프로그램의 복제본을 실행시키는 두 프로세스를 가지고 있다. 단 하나의 차이점은 pid의 값이다. 자식 프로세스는 0이며, 부모 프로세스는 0보다 큰 정수(사실 자식 프로세스의 pid이다.)이다.

    pid의 값이라는건 [Figure 3.8, p116]처럼 항상 정수가 되는게 아닌가? pid의 값이 아니라 fork()에 의한 리턴 값을 말하는거 같은데?

자식 프로세스는 부모로부터 특권과 스케쥴링 속성, 그리고 열려 있는 파일과 같은 특정 자원을 상속 받았다. 자식 프로세스는 자신의 address-space에 execlp() system call(=exec())을 사용하는 유닉스 명령어 /bin/ls를 overlay한다. 부모 프로세스는 wait() system call로 자식 프로세스가 완료 되기를 기다린다. 자식 프로세스가 완료되면(명시적이든 묵시적이든, exit() invoke에 의한 종료) 부모 프로세스는 wait()에서부터 재개하고 exit() system call을 사용하여 프로세스를 완료한다. (Figure 3.10, p119)

물론 자식 프로세스가 exec()를 호출하지 않고 부모 프로세스의 복제본으로서 계속 실행하는 것을 예방할 수 없다. 이것을 부모 프로세스와 자식 프로세스가 같은 code instruction을 실행하는 concurrent process _(프로세스의 상태에 대한 명칭인듯)_ 라고 한다. 자식 프로세스는 부모 프로세스의 복제본이기에 각 프로세스는 데이터의 복제본을 가지고 있다.

다른 예로서, 윈도우즈에서의 프로세스 생성을 생각하자. 부모 프로세스가 자식 프로세스를 생성하는 fork()와 유사한, Windows API의 CreateProcess() function을 사용해서 프로세스를 생성한다. 그러나 fork()가 부모 프로세스의 address-space를 상속받는 자식 프로세스를 생성하는 것과 달리 CreateProcess()는 프로세스를 생성할 때 자식 프로세스의 address-space에 특정 프로그램을 로드하는 것을 요구한다. 게다가 fork()는 파라미터가 없는 반면 CreateProcess() 10개 이상의 파라미터를 요구한다.

[Figure 3.11, p120]은 자식 프로세스를 생성하는 CreateProcess()를 보여준다. 생성된 자식 프로세스는 mspaint.exe를 로드한다. 10개의 기본 파라미터 값을 CreateProcess에 전달했다. Windows API의 프로세스 생성과 관리에 대해 관심이 있는 사람은 이 장의 끝에 참고문헌을 찾아보아라.

CreateProcess()에 전달된 두 파라미터는 STARTUPINF0와 PROCESS_INFORMATION구조체의 인스턴스이다. STARTUPINF0는 창 크기, 모습, 표준 입출력 파일의 조작과 같은 프로세스의 많은 프로퍼티를 명시한다. PROCESS_INFORMATION 구조체는 새롭게 생성된 프로세스와 그 스레드에 대한 식별자, 핸들을 가지고 있다. CreateProcess()를 진행하기에 앞서 ZeroMemory()를 호출하여 이 구조체들 각각에 메모리를 할당한다.

CreateProcess()에 처음 전달된 두 파라미터는 어플리케이션 이름과 command-line parameter다. 만일 어플리케이션의 이름이 NULL이라면, command-line parameter는 로드할 프로그램을 명시한다. 지금의 경우 mspaint.exe 어플리케이션을 로드한다. [Figure 3.11, p120]에서는 처음 두 파라미터를 지나, 프로세스 플래그가 없을 것이라는 명시와 프로세스의 상속, 스레드 핸들을 위한 기본 파라미터를 사용할 것이다. 또, 부모 프로세스의 environment block과 시작 디렉토리를 사용한다. 마지막으로, 프로그램이 시작할 때 생성된 STARTUPINF0, PROCESS_INFORMATION 구조체를 가리키는 포인터를 제공한다. [Figure 3.9, p118]은 부모 프로세스는 wait()을 호출하여 자식 프로세스의 완료를 기다린다. 윈도우즈에서도 동일한 기능을 하는 WaitForSingleObject()은 자식 프로세스 pi.hProcess의 조작을 전달하고 자식 프로세스의 완료를 기다린다. 자식 프로세스가 종료되면, 제어권은 부모 프로세스의 WaitForSingleObject()로부터 돌아온다.

---

프로세스는 또 다른 프로세스를 생성할 수 있다. 이는 트리를 형성하는데 각 프로세스는 pid로 구별된다.

새로운 프로세스는 작업을 수행하기 위해서 자원을 필요로 할 것이다. 자원은 os 또는 부모로부터 얻을 수 있다. 부모는 자원 말고도 자식 프로세스가 수행하기 위한 정보를 제공하기도 한다.

부모와 자식 프로세스는 동시에 실행되거나 부모 프로세스가 자식 프로세스를 기다리는 모습을 보인다.

자식 프로세스의 address-space는 부모와 동일하거나 새롭게 구성된다.
fork()는 프로세스의 복제를, exec()는 프로세스 address-space의 재구성(또는 overlay)을 담당한다.

윈도우즈는 명칭만 다르기에 제낀다....
