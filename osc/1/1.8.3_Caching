정보는 메인 메모리와 같은 저장 시스템에 있어야 한다.
정보를 사용하기 위해서는 캐시같은 빠른 저장 시스템에 복사되어야 한다.
정보의 일부를 사용하고자 할 때 캐시에 정보가 있는지 확인한다.
	정보가 있다면 직접 캐시로부터 정보를 사용하고,
	정보가 없다면 source로부터 정보를 사용하고, 다시 사용할 가능성을 두고 캐시로 복사한다.

인덱스 레지스터와 같은 레지스터들은 메인 메모리에 고속 캐시를 제공한다.
프로그래머는 
	레지스터나 메인 메모리에 정보를 keep하는 것을 결정하기 위해
	레지스터를 할당과 레지스터변환 알고리즘을 적용한다.

캐시가 없다면 cpu는 명령이 메인 메모리로부터 인출될 때까지 몇 사이클을 기다려야 한다.
이런 이유로 대부분의 시스템에서는 하나 이상의 고속 데이터 캐시를 메모리 체계에 가지고 있는데,
	이는 os의 관할 대상이 아니기 때문에 다루지 이 책에서는 않는다.

#28쪽 Main memory으로 시작하는 문단 이해가 안됨.

저장 체계의 레벨간의 움직임은 명시적 혹은 묵시적이고, 하드웨어 디자인과 os sw의 제어에 달려있다.
예를 들어, 캐시에서 cpu와 레지스터로의 데이터 전송은 하드웨어 기능이고, 
	디스크에서 메모리로의 데이터 전송은 os에 의해 제어된다.

계층형 저장구조에서 서로 다른 계층에 같은 데이터가 존재한다.
예를 들어,
	magnetic disk의 파일 B에 있는 integer A가 1증가 한다고 가정하자.
	우전 증가 연산은 i/o연산을 issue하고 magnetic disk의 해당 disk block을
	A가 위치한 메모리 블록에 복사한다.
	그리고 A를 다시 캐시와 내부 레지스터에 복사한다.
	따라서 A는 magnetic disk, main memory, cache, internal register에 나타난다.
	increment가 register에서 일어나면 A의 값은 저장시스템마다 다르다.
	A의 값은 내부 레지스터에서 magnetic disk로 돌아가 쓰여진 후에만 일치하는 값이 된다.

하나의 process만 실행되는 환경에서는 이런 과정이 문제가 되지 않지만,
cpu의 스위치가 일어나는 multitasking 환경에서 여러 process가 A에 접근하고자 하면 
각각은 가장 최근에 업데이트된 A값을 얻게되기 때문에 매우 조심해야한다.

cpu각각이 local cache를 가지고 있는 multiprocessor 환경에서는 A는 동시에 각각의 cache에 존재할 것이다.
	cpu들은 병렬적으로 모두 실행될 수 있기 때문에, 하나의 cache에 존재하는 A의 값이 바뀌면
	즉시 다른 cache에 이를 반영해야한다. 이를 cache coherency라고 부르며 일반적인 하드웨어 issue이다.

같은 파일이 다른 컴퓨터에 복사되는 분산 환경에서도 마찬가지로 하나의 replica에서 값이 바뀌면
즉시 다른 replica를 최신화한다.


