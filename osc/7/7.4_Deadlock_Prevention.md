# 7.4 Deadlock Prevention
---

7.2.1절에서 보였듯이 데드락이 발생하기 위해서는 네 개의 필요 조건을 만족해야 한다. 이 조건 중 최소 하나라도 만족할 수 없게 한다면 데드락의 발생을 *예방*할 수 있다. 네 필요 조건을 각각 설명함으로써 이 접근법에 대해 자세히 설명한다.

## 7.4.1 Mutual Exclusion
---

mutual exclusion condition은 만족되어야만 한다. 즉 최소 하나의 자원은 공유 불가능해야 한다. 대조적으로, 공유 가능한 자원은 상호간 exclusive access를 요구하지 않고, 데드락에 포함될 수 없다. 읽기 전용 파일은 공유 가능한 자원의 좋은 예다. 개별적인 프로세스가 동시에 읽기 전용 파일을 열려고 시도한다면 이들은 파일에 대한 동시적인 액세스 권한을 얻을 수 있다. 프로세스는 공유 가능한 자원을 기다릴 필요가 없다. 하지만 일반적으로 mutual-exclusion 조건을 부정하는 것으로는 데드락을 예방할 수 없다. 이는 어떤 자원은 본질적으로 공유 불가능하기 때문이다. 예를 들어 mutex lock은 여러 프로세스에 의해 동시에 공유될 수 없다.

## 7.4.2 Hold and Wait
---

hold-and-wait 조건이 시스템에서 발생하지 않기 위해서는 프로세스가 자원을 언제 요청하든지 다른 자원을 점유하고 있지 않음을 보장해야 한다. 우리가 사용할 수 있는 한 프로토콜은, 프로세스가 실행을 시작하기 전에 자원을 요청하고 할당받을 것을 요구한다. 프로세스를 위한 자원을 요청하는 system call은 다른 system call보다 선행되는 것을 요구함으로써 이것을 구현할 수 있다.

한 가지 대체 프로토콜은 프로세스가 자무것도 점유하고 있지 않을 때만 자원을 요청하는 것을 허용한다. 프로세스는 자원을 요청하고 사용할 것이다. 프로세스가 추가적인 자원을 요청하기 전에 현재 할당 받은 모든 자원을 반환해야만 한다.

이 두 프로토콜의 다이를 설명하기 위해서, 프로세스가 DVD drive에서 disk의 파일로 데이터를 복제하는 것과 파일을 정렬해서 그 결과를 프린트로 출력하는 것을 생각하자. 모든 자원이 프로세스의 시작과 함께 요청받아야만 한다면, 프로세스는 초기에 DVD drive, disk file, printer를 요청해야 할 것이다. 이것은 프린터가 마지막에 사용됨에도 프로세스의 전체 실행동안 프린터를 점유하고 있을 것이다.

두 번째 방법은 프로세스가 초기에 DVD drive와 disk file만을 요청하도록 한다. DVD drive로부터 disk로 복사하고 DVD drive와 disk file을 반환한다. 그러면 프로세스는 disk file과 printer를 요청해야 한다. disk file로부터 프린터로의 복사 후에, 프로세스는 두 자원을 반환하고 종료한다.

이 두 프로토콜은 두 가지 주된 단점을 가지고 있다. 첫 번째는, 자원이 할당되지만 오랜 시간 사용되지 않을 수 있기 때문에 자원의 사용이 낮아진다는 것이다. 예를 들어, 주어진 예제에서 DVD drive와 disk file을 반환할 수 있고, disk file에 데이터가 남아 있다고 확신할 수 있을 때만 disk file과 프린터를 요청할 것이다. 그렇지 않으면 두 프로토콜이 시작할 때 모든 자원을 요청해야 한다.

두 번째는 starvation의 가능성이다. 인기 있는 몇몇 자원을 필요로 하는 프로세스는, 필요로 하는 최소 하나의 자원이 항상 다른 프로세스에 할당되기 때문에 무기한으로 기다려야만 할 것이다.

## 7.4.3 No Preemption
---

데드락의 세 번째 필요 조건은 이미 할당된 자원의 preemption이 없다는 것이다. 이 조건을 만족시키지 않기 위해 다음의 프로토콜을 사용할 수 있다. 프로세스가 자원을 점유하고 있고 즉시 할당될 수 없는 자원을 요청한다면, 현재 프로세스가 점유하고 있는 모든 자원은 선점당한다. 다른 말로, 이 자원들은 암묵적으로 반환된다. 선점당한 프로세스들은 프로세스가 기다리고 있는 자원 리스트에 추가 된다. 프로세스는 사용하던 자원을 다시 얻을 때, 새로운 프로세스를 요청할 때 모두 재시작될 것이다.

대안적으로, 프로세스가 여러 자원을 요청하면 우선 자원이 이용 가능한지를 확인한다. 자원이 이용 가능하다면 프로세스에 할당한다. 그렇지 않다면, 자원이 추가적인 자원을 기다리는 다른 프로세스에 할당되었는지 확인한다. 할당되었다면, 대기 중인 프로세스가 원하고 있는 자원을 선점하고 앞의 요청하는 프로세스에 할당한다. 자원이 기용 가능하거나 다른 대기 중인 프로세스에 의해 점유되고 있지 않다면 요청하는 프로세스는 기다려야만 한다. 프로세스가 기다리는 동안, 다른 프로세스가 그 자원을 요청한다면 자원을 선점당한다. 프로세스는 요청한 새로운 자원을 할당받았을 때만 재시작될 수 있고, 기다리는 동안 선점 당했던 자원을 회복할 것이다.//

이 프로토콜은 CPU 레지스터와 memory space 같은 자원의 상태가 나중에 쉽게 저장되고 복원될 수 있는 자원에 종종 적용되곤 한다. 이 프로토콜은 일반적으로 mutex lock과 세마포어와 같은 자원에 적용될 수 없다.

## 7.4.4 Circular Wait
---

마지막 네 번째 데드락 조건은 circular-wait 조건이다. 이 조건이 절대 만족하지 않도록 보장하는 방법은 모든 resource type에 순서를 부여하는 것과 각 프로세스가 올림차순의 순서로 자원을 요구하는 것이다.

이를 설명하기 위해서, *R* = {*R1*, *R2*, ... *Rm*}를 resource type의 집합으로 놓자. 각 resource type에 고유한 정수 값을 할당한다. 이 숫자는 두 자원을 비교할 수 있고 순서에 따라 선행되는 한쪽을 결정할 수 있게 한다. 공식적으로는 일대일 함수 *F*: *R* -> *N*을 정의한다. *N*은 자연수의 집합이다. 예를 들어 resource type *R*이 tape drive, disk drive, printer를 포함한다면 함수 *F*는 다음처럼 정의되었을 것이다. 

	*F*(tape drive) = 1
	*F*(disk drive) = 5
	*F*(printer) = 12

데드락을 예방하기 위해서 다음의 프로토콜을 생각할 수 있다. 각 프로세스는 순서의 오름차순으로만 자원을 요청할 수 있다. 극 프로세스는 초기에 resource type 인스턴수의 일정 수를 요청할 수 있다. 그 후에, *F*(*Rj*) > *F*(*Ri*)일 경우만 프로세스는 resource type *Rj*의 인스턴스를 요청할 수 있다. 예를 들어 이전에 정의된 함수를 사용하는 것은 tape drive와 프린터를 동시에 사용하기 원하는 프로세스는 첫 번째로 tape drive를 요청하고 이후에 프린터를 요청해야만 한다. 대안적으로, *F*(*Ri*) >= *F*(*Rj*)처럼 우리는 resource type *Rj*의 인스턴스를 요청하는 프로세스가 resource *Ri*를 반환했어야 한다고 요구할 수 있다. 얼마간의 같은 resource type 인스턴스가 요구된다면 모두에 대한 *single* request가 발행되어야 하는 것을 주목하자.

이 두 프로토콜이 사용된다면 circular-wait 조건은 만족될 수 없다. circular wait가 존재한다는 가정을 통해 이를 증명할 수 있다. circular wait에 포함된 프로세스 집합을 {*P0*, *P1*, ... *Pn*}이라고 하자. *Pi*는 프로세스 *Pi+1*에 의해 점유된 자원 *Ri*을 기다린다(n+1은 0이 되는 modulo arithmetic이 사용된다). 그러면 프로세스 *Pi+1*이 *Ri+1*을 요청하는 동안 자원 *Ri*를 점유하고 있기 때문에 모든 *i*에 대해서 *F*(*Ri*) < *F*(*Ri+1*)를 가져야만 한다. 하지만 이 조건은 *F*(*R0*) < *F*(*R1*) < ... < *F*(*Rn*) < *F*(*R0*)을 의미한다. *F*(*R0*) < *F*(*R0*)은 불가능하다. 그러므로 circular wait는 존재할 수 없다.

시스템의 모든 synchronization object 간 순서를 개발함으로써 어플리케이션 프로그램에 이 스키마를 완성시킬 수 있다. synchronization object에 대한 모든 요청은 오름차순으로 만들어져야 한다. 예를 들어 [Figure 7.4, p326]에서 보이는 Pthread 프로그램에서 순서를 갖는 lock이 
	
	*F*(first_mutex) = 1
	*F*(second_mutex) = 5

였다면 *thread_two*는 임의의 순서로 lock을 요청할 수 없다.

순서 또는 계층을 개발하는 것은 그 자체로 데드락을 예방하지 않음을 염두해두자. 순서를 따르는 프로그램을 작성하는 것은 어플리케이션 개발자의 역할이 된다. 또한 함수 *F*는 시스템에서의 자원 사용의 일반적인 순서에 따라 정의되어야만 한다. 예를 들어, tape drive는 보통 프린터보다 먼저 요구되기 때문에 *F*(tape drive) < *F*(printer)로 정의하는 것이 합리적이다.

자원이 적절한 순서로 획득되도록 하는 것은 어플리케이션 개발자의 책임이지만, 특정 소프트웨어는 lock이 적절한 순서로 획득되었는지 확인하고 lock이 임의의 순서로 획득되고 데드락의 가능성이 있을 때 적정한 경고를 주기위해서 사용될 수 있다. FreeBSD와 같은 UNIX의 BSD버전에서 동작하는 lock-order verifier는 `witness`로 알려져 있다. witness는 5장에서 설명한 critical section을 보호하기 위해서 mutual-exclusion lock을 사용한다. 이것은 시스템의 lock 순서의 관계를 동적으로 유지함으로써 동작한다. [Figure 7.4, p326]에 내타낸 프로그램을 사용해보자. *thread_one*은 첫 번째로 lock을 획득하고 *first_mutex*, *second_mutex* 순으로 수행한다. witness는 *first_mutex*가 *second_mutex* 이전에 얻어져야만 하는 관계를 기록한다. *thread_two*가 나중에 임의의 순서로 lock을 얻는다면 witness는 시스템 콘솔에 경고 메시지를 생성한다.

lock이 동적으로 획득될 수 있다면, lock 순서를 도입하는 것이 데드락 예방을 보장하지 않는 것을 인지하는 것이 중요하다. 예를 들어 두 계좌 간 이체를 담당하는 함수가 있다고 가정하자. race condition을 예방하기 위해서 각 계좌는 [Figure 7.5, p327]에 나타난 *get_lock()*함수로부터 얻어진 mutex lock과의 관계를 갖는다. 두 개의 스레드가 동시에 *transaction()* 함수를 호출한다면 데드락의 가능성이 존재하고 순서를 뒤바꾼다. 즉 한 스레드가 
	
	*transaction(*checking_account*, *savings_account*, 25);

를 호출할 것이고 다른 스레드는

	*transaction(*savings_account*, *checking_account*, 50);

을 호출할 것이다.

이 상황을 수정하는 것을 연습문제에 남긴다.
