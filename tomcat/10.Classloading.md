# 10. Classloading
---
## Class Loader 사용법

### 목차
* 개요
* Class Loader의 정의
* XML Parser and Java
* security manager 관리하에 실행

#### 개요
다른 서버 어플리케이션처럼, 톰캣은 컨테이너의 여러 구성원들과 컨테이너에서 실행되는 웹 어플리케이션이 클래스와 리소스의 저장소 들에 접근할 수 있도록 다양한 class loader를 설치한다. 이 메커니즘은 Servlet Specification 2.4에 정의된 기능을 제공하기 위해서 사용된다.

자바 환경에서 class loader는 parent-child tree 내에 위치하게 된다. 일반적으로 class loader가 클래스나 리소스를 로드하기 위한 요청을 하게되면, class loader는 parent class loader에 먼저 요청을 위임한다. parent class loader는 요청에 해당하는 클래스 또는 리소스를 찾고, 찾지 못하면 처음 요청을 받았었던 class loader의 저장소에서 찾게 된다. 웹 어플리케이션 class loader의 모델은 이것과는 약간 다르지만 기본 원리는 같다.

톰캣이 실행될 때 다음과 같은 parent-child 관계를 가진 class loader가 형성된다.
<br>
Bootstrap - System - Common - [Webapp1, Webapp2, ...]

클래스와 리소스가 가시화 하는 source를 포함하는 각 class loader의 특징은 다음 절에서 다룬다.

#### Class Loader의 정의
톰캣은 다음의 class loader를 생성하고 초기화 한다.
* Bootstrap - 이 class loader는 jvm에서 제공 받은 기본 런타임 클래스와 System Extensions directory($JAVA_HOME/jre/lib/ext)에 있는 JAR클래스를 포함한다. 어떤 jvm은 이를 하나 이상의 class loader로서 구현하거나, 아예 class loader로서 표시하지 않을 수 있다.

* System - 이 class loader는 일반적으로 CLASSPATH 환경 변수의 내용으로 초기화된다. 이런 클래스는 톰캣 내부 클래스와 웹 어플리케이션 모두에서 볼 수 있다.
<br>
반면에 표준 톰캣 startup 스크립트($CATALINA_HOME/bin/catalina.sh)는 CLASSPATH 환경 변수의 내용을 완전히 무시하고 그 대신 다음의 System class loader를 생성한다.

 * $CATALINA_HOME/bin/bootstrap.jar - 톰캣 서버를 초기화 하는데 사용되는 main()메서드를 가지고 있고 이 메서드가 의존하는 클래스를 구현한다.

 * $CATALINA_BASE/bin/tomcat-juli.jar - 로깅 구현 클래스. Tomcat JULI로 알려진 logginAPI를 강화하는 클래스와 톰캣 내부적으로 사용되는 Apache Commos Logging library의 복사본(이름은 다르다.)을 포함한다.
 <br>
 tomcat-juli.jar가 $CATALINA_BASE/bin에 위치한다면, $CATALINUA_HOME/bin에 있는 것 대신에 사용된다.

 * $CATALINA_HOME/bin/commons-daemon.jar - Apache Commons Daemon project에서 나온 클래스. 이 파일은 catalina.sh에 의해 빌드된 CLASSPATH에는 없지만 bootstrap.jar의 manifest 파일로부터 참조 된다.

* Common - 이 class loader는 톰캣 내부 클래스와 모든 웹 어플리케이션에서 볼 수 있도록 만들어진 추가 클래스가 포함되어 있다.
<br>
일반적으로 어플리케이션 클래스는 여기(Common class loader)에 위치해서는 안된다. 이 위치는 $CATALINA_BASE/conf/catalina.properties의 common.loader property에 의해 정의된 클래스로부터 탐색된다. 기본 설정은 다음의 위치를 순서대로 탐색한다.
 * unpacked classes and resources in $CATALINA_BASE/lib
 * JAR files in $CATALINA_BASE/lib
 * unpacked classes and resources in $CATALINA_HOME/lib
 * JAR files in $CATALINA_HOME/lib

 다음은 기본적으로 포함되는 것들이다.

 * annotations-api.jar — JavaEE annotations classes.
 * catalina.jar — Implementation of the Catalina servlet container portion of Tomcat.
 * catalina-ant.jar — Tomcat Catalina Ant tasks.
 * catalina-ha.jar — High availability package.
 * catalina-storeconfig.jar — Generation of XML configuration files from current state
 * catalina-tribes.jar — Group communication package.
 * ecj-\*.jar — Eclipse JDT Java compiler.
 * el-api.jar — EL 3.0 API.
 * jasper.jar — Tomcat Jasper JSP Compiler and Runtime.
 * jasper-el.jar — Tomcat Jasper EL implementation.
 * jsp-api.jar — JSP 2.3 API.
 * servlet-api.jar — Servlet 3.1 API.
 * tomcat-api.jar — Several interfaces defined by Tomcat.
 * tomcat-coyote.jar — Tomcat connectors and utility classes.
 * tomcat-dbcp.jar — Database connection pool implementation based on package-renamed copy of Apache Commons Pool and Apache Commons DBCP.
 * tomcat-i18n-\*\*.jar — Optional JARs containing resource bundles for other languages. As default bundles are also included in each individual JAR, they can be safely removed if no internationalization of messages is needed.
 * tomcat-jdbc.jar — An alternative database connection pool implementation, known as Tomcat JDBC pool. See documentation for more details.
 * tomcat-util.jar — Common classes used by various components of Apache Tomcat.
 * tomcat-websocket.jar — WebSocket 1.1 implementation
 * websocket-api.jar — WebSocket 1.1 API

* WebappX ([Webapp1, Webapp2, ...]) - 단일 톰캣 인스턴스에 배포되는 각각의 웹 어플리케이션에 대해 생성되는 class loader. 웹 어플리케이션의 /WEB-INF/classes 디렉토리에 압축을 푼 클래스와 리소스, /WEB-INF/lib 디렉토리 아래에 있는 JAR파일의 클래스와 리소스는 웹 어플리케이션에 보여진다. 다른 곳에서는 볼 수 없다.

언급했다시피, 웹 어플리케이션 class loader는 기본 java delegation model과는 다르다. 웹 어플리케이션의 WebappX class loader로부터 클래스의 load 요청이 실행될 때, 웹 어플리케이션 class loader는 탐색을 다른 class loader에 위임하지 않고 직접 local 저장소를 먼저 탐색한다.
<br>
여기에는 예외가 있는데, JRE기반의 클래스는 override되지 않는다.(여기에도 몇 가지 예외가 있다. 예를 들어, JVM은 java 8 이하 버전에 대해서 표준 override를 시행하는 기능을 제공하는데 이를 이용하면 XML parser component가 override될 수 있고, 또한 java 9 이상 버전에 대한 개선 가능한 모듈도 예외가 될 수 있다.)
Lastly, the web application class loader will always delegate first for JavaEE API classes for the specifications implemented by Tomcat(Servlet, JSP, EL, WebSocket). 이들과 다른 톰캣의 모든 class loader는 일반적인 delegation pattern을 따른다.
<br>
그러므로 웹 어플리케이션의 관점에서, 클래스와 리소스 로딩은 다음의 저장소에서 순서대로 나타난다.
* Bootstrap classes of your JVM
* /WEB-INF/classes of your web application
* /WEB-INF/lib/\*.jar of your web application
* System class loader classes (described above)
* Common class loader classes (described above)

웹 어플리케이션 class loader 설정을 <Loader delegate="ture"/>으로 바꿔주면 순서는 다음과 같이 바뀐다.
* Bootstrap classes of your JVM
* System class loader classes (described above)
* Common class loader classes (described above)
* /WEB-INF/classes of your web application
* /WEB-INF/lib/\*.jar of your web application

#### XML Parsers and Java
자바 1.4 버전에서 JAXP APIs의 복사본과 XML parser가 JRE에 포함되었다. 이것은 내부의 XML parser를 이용하려는 어플리케이션에 영향을 주었다.
<br>
톰캣의 오래된 버전에서, 모든 웹 어플리케이션에서 사용하는 parser를 바꾸기 위해서  톰캣 라이브러리 디렉토리에 있는 XML parser를 쉽게 대체할 수 있었다. 하지만 이 기술은 최근 버전의 자바를 실행할 때 효과적이지 않다. 일반적인 class loader delegation process가 우선적으로 JDK의 내부 implementation을 선택하기 때문이다.
<br>
자바 8 이하의 버전은 JCP(W3C의 DOM, SAX)의 밖에서 만들어진 APIs를 대체하도록 _"Endorsed Standards Override Mechanism"_ 이라는 메커니즘을 제공한다. 이것은 또한 XML parser implementation을 업데이트 하는데도 사용될 수 있다.

#### Running under a security manager
security manager 하에서, 클래스가 로드될 수 있는 위치는 policy file의 내용에 의존한다. 자세한 내용은 Security Manager HOW-TO를 참조하라.

---

컨테이너의 클래스와 리소스에 접근하는 class loader.
<br>
class loader는 parent-child관계에 따라서 탐색 순서가 정해진다.
<br>
톰캣은 Bootstrap - System - Common - WebappX의 계층형태를 가진다.
<br>
웹 어플리케이션은 parent-child관계의 탐색 순서를 따르기보다는 local 저장소를 먼저 탐색한다.
<br>
일반적으로 JDK 내부 implementation을 먼저 선택하기 때문에 톰캣 내부의 xml parser를 바꾸는 것은 효율적이지 않다.
